//! Worker session update message and its signed version.

use scale::{Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;

use crate::{
    crypto::{
        verify::{verify_message, Verifiable},
        CryptoProvider, Signature,
    },
    primitives::{BoundedVec, WorkerPubkey},
    Address, ContentType,
};

/// A session update info.
#[derive(Debug, Clone, Encode, Decode, TypeInfo, MaxEncodedLen, PartialEq, Eq)]
pub struct SessionUpdate {
    /// The session id.
    pub session: [u8; 32],
    /// The seed of the session which is generated by the worker on initialization.
    pub seed: [u8; 32],
    /// The account address that used to receive the settlement payment.
    pub reward_receiver: BoundedVec<u8, 32>,
}

impl SessionUpdate {
    /// Calculate the session id from the seed and nonce.
    pub fn session_from_seed<Crypto: CryptoProvider>(seed: [u8; 32], nonce: &[u8]) -> [u8; 32] {
        Crypto::blake2b_256(&[&seed, nonce].concat())
    }

    /// Create a new session update.
    pub fn new<Crypto: CryptoProvider>(
        seed: [u8; 32],
        nonce: &[u8],
        reward_receiver: Address,
    ) -> Self {
        let session = Self::session_from_seed::<Crypto>(seed, nonce);
        Self {
            session,
            seed,
            reward_receiver: reward_receiver.to_vec().into(),
        }
    }
}

/// A signed session update.
#[derive(Debug, Clone, Encode, Decode, TypeInfo, PartialEq, Eq)]
pub struct SignedSessionUpdate {
    /// The session update data.
    pub update: SessionUpdate,
    /// The signature of the update.
    pub signature: Signature,
    /// The public key of the worker that signed the update.
    pub public_key: WorkerPubkey,
}

impl Verifiable for SignedSessionUpdate {
    fn verify<Crypto: CryptoProvider>(&self) -> bool {
        let message = self.update.encode();
        verify_message::<Crypto>(
            ContentType::SessionUpdate,
            &message,
            &self.signature,
            &self.public_key,
        )
    }
}
