//! Worker session update message and its signed version.

use scale::{Decode, Encode, MaxEncodedLen};
use scale_info::TypeInfo;

use crate::{
    crypto::{
        verify::{verify_message, Verifiable},
        CryptoProvider, Signature,
    },
    primitives::{BoundedVec, WorkerPubkey},
    Address, ContentType,
};

/// A session update info.
#[derive(Debug, Clone, Encode, Decode, TypeInfo, MaxEncodedLen, PartialEq, Eq)]
pub struct SessionUpdate {
    /// The session id.
    pub session: [u8; 32],
    /// The nonce for the session generated by the worker.
    pub nonce: [u8; 32],
    /// The account address that used to receive the settlement payment.
    pub recipient: BoundedVec<u8, 32>,
}

impl SessionUpdate {
    /// Calculate the session id from the seed and nonce.
    ///
    /// The session id is calculated as `blake2b_256(nonce || metrics_nonce)` where `nonce` is generated
    /// on-the-fly by the worker and `metrics_nonce` should be the last metrics nonce submitted to the chain.
    pub fn calc_session_id<Crypto: CryptoProvider>(
        nonce: [u8; 32],
        metrics_nonce: &[u8],
    ) -> [u8; 32] {
        Crypto::blake2b_256(&[&nonce, metrics_nonce].concat())
    }

    /// Create a new session update.
    pub fn new<Crypto: CryptoProvider>(
        nonce: [u8; 32],
        metrics_nonce: &[u8],
        recipient: Address,
    ) -> Self {
        let session = Self::calc_session_id::<Crypto>(nonce, metrics_nonce);
        Self {
            session,
            nonce,
            recipient: recipient.to_vec().into(),
        }
    }
}

/// A signed session update.
#[derive(Debug, Clone, Encode, Decode, TypeInfo, PartialEq, Eq)]
pub struct SignedSessionUpdate {
    /// The session update data.
    pub update: SessionUpdate,
    /// The signature of the update.
    pub signature: Signature,
    /// The public key of the worker that signed the update.
    pub public_key: WorkerPubkey,
}

impl Verifiable for SignedSessionUpdate {
    fn verify<Crypto: CryptoProvider>(&self) -> bool {
        let message = self.update.encode();
        verify_message::<Crypto>(
            ContentType::SessionUpdate,
            &message,
            &self.signature,
            &self.public_key,
        )
    }
}
